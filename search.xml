<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity反应式编程库R3</title>
      <link href="/2024/11/06/Unity%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%BA%93R3/"/>
      <url>/2024/11/06/Unity%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%BA%93R3/</url>
      
        <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>方式一：<br>1.unity包管理器安装NuGetForUnity<br>2.从NuGet打开窗口 -&gt; 管理NuGet包，搜索“R3”并按安装。</p><p>方式二：<br>通过git URL直接安装：<br><a href="https://github.com/Cysharp/R3.git?path=src/R3.Unity/Assets/R3.Unity">https://github.com/Cysharp/R3.git?path=src/R3.Unity/Assets/R3.Unity</a></p><h3 id="反应式X（Reactive-X）"><a href="#反应式X（Reactive-X）" class="headerlink" title="反应式X（Reactive X）"></a>反应式X（Reactive X）</h3><pre><code>    ReactiveX 是一个库，用于使用可观察序列编写异步和基于事件的程序。它扩展了观察者模式以支持数据和/或事件序列，并添加了运算符，允许您以声明方式将序列组合在一起，同时抽象出对低级线程、同步、线程安全、并发数据结构和非阻塞 I/O 等问题的关注。</code></pre><h3 id="ReactiveX的操作符"><a href="#ReactiveX的操作符" class="headerlink" title="ReactiveX的操作符"></a>ReactiveX的操作符</h3><ul><li>创建可观察序列：<br>创建新事件源的操作符。<ul><li>Create ： 通过调用观察者的方法从无到有创建一个事件源</li><li>Defer ： 在观察者订阅之前不会创建事件源，并为每个观察者创建一个新的事件源</li><li>Empty&#x2F;Never&#x2F;Throw ： 创建具有非常明确和有限行为的事件源</li><li>From ： 将一些其他对象或数据结构转换为事件源</li><li>Interval ： 创建一个事件源，它以给定的时间间隔发出一系列整数</li><li>Just ： 将对象或一组对象转换为发出该对象或那些对象的事件源</li><li>Range ： 创建一个事件源，它发出一系列连续整数，从指定的开始值到指定的结束值</li><li>Repeat ： 创建一个事件源，重复发出特定事件或事件序列</li><li>Start ：  创建一个发出函数返回值的事件源</li><li>Timer ： 创建一个事件源，它在指定的时间间隔后发出一个值</li></ul></li><li>转换事件源：<br>转换事件源发出的事件的操作符。<ul><li>Buffer ： 周期性的将事件源发出的事件收集成捆并发出这些捆绑事件，而不是一次发送一个事件</li><li>FlatMap ： 将事件源发出的事件转换为多个事件源，然后将这事件的依次发出</li><li>GroupBy ： 将一个事件源根据不同的事件按key划分为一组事件源</li><li>Map ： 每个事件源发出的事件通过将函数处理后在发出</li><li>Scan ： 依次的用聚合函数处理事件源发出的事件, 并发出每个连续的值</li><li>Window ： 将事件源中的事件周期性划分为事件源窗口并发出这些窗口，而不是一次发出一个事件</li></ul></li><li>过滤事件源：<br>从源事件源有选择地发出事件的操作符。<ul><li>Debounce ： 如果特定的时间跨度已经过去而没有发出另一个事件则从事件源发出一个事件</li><li>Distinct ： 过滤掉重复的事件</li><li>ElementAt ： 仅从事件源发出位置n的事件</li><li>Filter ： 过滤掉不符合条件的事件</li><li>First ： 仅从事件源发出第一个符合条件的事件</li><li>IgnoreElements ： 丢弃事件源发出的事件，只保留完成通知</li><li>Last ： 仅从事件源发出最后一个符合条件的事件</li><li>Sample ： 周期性的从事件源发出最近的事件</li><li>Skip ： 跳过事件源发出的前n个事件</li><li>SkipLast ： 跳过事件源发出的最后n个事件</li><li>Take ： 只从事件源发出前n个事件</li><li>TakeLast ： 只从事件源发出最后n个事件</li></ul></li><li>组合事件源：<br>通过合并多个源事件源创建一个事件源的操作符。<ul><li>And&#x2F;Then&#x2F;When ： 使用Pattern和Plan中介组合两个或多个事件源发出的事件</li><li>CombineLatest ： 当两个事件源中的任何一个发出一个事件时，通过指定的函数组合每个事件源发出的最新事件并发出</li><li>Join ： 在另一个事件源发出的事件定义的时间窗口期间发出一个事件源中的事件，组合两个事件源发出的事件</li><li>Merge ： 将多个事件源合并为一个事件源，并发出所有事件</li><li>StartWith ： 在事件源发出第一个事件之前发出一些初始值</li><li>Switch ： 切换到另一个事件源，取消订阅当前事件源并订阅新事件源</li><li>Zip ： 将两个事件源中的事件按顺序组合成元组并发出</li></ul></li><li>错误处理：<br>有助于捕获事件源的错误通知的操作符。<ul><li>Catch ： 捕获事件源中的错误并将其转换为另一个事件源发出的事件</li><li>Retry ： 重新订阅事件源，直到成功或达到最大重试次数</li></ul></li><li>公共操作符：<br>用于处理事件源的有用操作符的集合。<ul><li>Delay ： 延迟事件源发出的事件</li><li>Do ： 在事件源发出事件时执行指定的动作</li><li>Materialize&#x2F;Dematerialize ： 发出表达事件源发出的事件（通知）类型，和逆操作</li><li>ObserveOn ： 指定观察者将观察此事件源的调度程序</li><li>Serialize ： 强制事件源进行序列化调用并保持良好行为和同步</li><li>Subscribe ： 根据事件源的发出的事件或通知进行操作</li><li>SubscribeOn ： 指定事件源在订阅时应使用的调度器</li><li>TimeInterval ： 将发出事件的事件源转换为发出这些事件之间的时间间隔</li><li>Timeout ： 镜像源事件源，但如果在指定时间段内没有任何发出的事件，则发出错误通知</li><li>Timestamp ： 为事件源发出的每个事件附加时间戳</li><li>Using ： 创建与事件源具有相同生命周期的可支配资源</li></ul></li><li>条件操作符：<br>评估事件源发出的一个或多个事件源或事件的操作符。<ul><li>All ： 确定事件源发出的所有事件是否符合某些条件</li><li>Amb ： 给定两个或多个源事件源，仅从第一个发出事件或通知的事件源中发出所有事件</li><li>Contains ： 确定事件源是否发出指定项目</li><li>DefaultIfEmpty ： 如果源事件源不发出任何内容，则发出默认事件</li><li>SequenceEqual ： 确定两个事件源是否发出相同的事件序列</li><li>SkipUntil ： 丢弃事件源发出的事件，直到第二个事件源发出事件为止</li><li>SkipWhile ： 丢弃事件源发出的事件，直到指定的条件变为false</li><li>TakeUntil ： 在第二个事件源发出事件或终止后，丢弃事件源发出的事件</li><li>TakeWhile ： 在指定条件变为false后丢弃事件源发出的事件</li></ul></li><li>算术操作符：<br>对事件源发出的整个事件序列进行算术运算的操作符。<ul><li>Average ： 计算事件源发出的数字的平均值并发出此数值</li><li>Concat ： 无交叉的拼接两个或多个事件源发出的事件</li><li>Count ： 计算源事件源发出的事件数并发出此数值</li><li>Max ： 计算事件源发出的数字的最大值并发出此数值</li><li>Min ： 计算事件源发出的数字的最小值并发出此数值</li><li>Reduce ： 相继的用函数处理事件源发出的事件, 并发出最终的值</li><li>Sum ： 计算事件源发出的数字的和并发出此数值</li></ul></li><li>背压（backpressure）操作符：   <ul><li>backpressure operators ： 当事件源比观察者消耗速度更快的发出事件时的应对策略</li></ul></li><li>连接操作符：<br>精确控制的订阅动态的特殊事件源。<ul><li>Connect ： 订阅事件源，直到观察者取消订阅</li><li>Publish ： 立即创建事件源的热备份，并将其发出的事件广播到所有订阅者</li><li>RefCount ： 保持事件源的热备份，直到最后一个观察者取消订阅</li><li>Replay ： 立即创建事件源的热备份，并将其发出的事件缓冲并重放给订阅者</li></ul></li><li>转换操作符：<ul><li>To ： 将事件源转换为其他类型，例如IEnumerable、IObservable、IObserver等。</li></ul></li></ul><h3 id="常用Linq操作符"><a href="#常用Linq操作符" class="headerlink" title="常用Linq操作符"></a>常用Linq操作符</h3><ol><li><p>Select ： 选择集合中的特定字段。 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = people.Select(p =&gt; p.Name);</span><br></pre></td></tr></table></figure></li><li><p>Where ： 过滤集合中的元素，返回满足条件的元素。   </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adults = people.Where(p =&gt; p.Age &gt;= <span class="number">18</span>);</span><br></pre></td></tr></table></figure></li><li><p>OrderBy &#x2F; OrderByDescending ： 对集合中的元素进行排序。   </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortedPeople = people.OrderBy(p =&gt; p.Name);   </span><br><span class="line"><span class="keyword">var</span> sortedPeopleDesc = people.OrderByDescending(p =&gt; p.Age);</span><br></pre></td></tr></table></figure></li><li><p>GroupBy ： 根据某个字段对集合进行分组。   </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> groupedByAge = people.GroupBy(p =&gt; p.Age);</span><br></pre></td></tr></table></figure></li><li><p>Join ： 连接两个集合，根据某个字段进行匹配。   </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> p <span class="keyword">in</span> people</span><br><span class="line">    <span class="keyword">join</span> o <span class="keyword">in</span> orders <span class="keyword">on</span> p.Id <span class="keyword">equals</span> o.PersonId  </span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span> &#123; p.Name, o.OrderAmount &#125;;</span><br><span class="line">```  </span><br><span class="line"><span class="number">6.</span> Distinct ： 返回集合中的不重复元素。   </span><br><span class="line">```c<span class="meta">#</span></span><br><span class="line"><span class="keyword">var</span> uniqueNames = people.Select(p =&gt; p.Name).Distinct();</span><br></pre></td></tr></table></figure></li><li><p>Skip &#x2F; Take ： 跳过&#x2F;取前n个元素。   </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstThree = people.Take(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> skipTwo = people.Skip(<span class="number">2</span>).Take(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li><li><p>Any ： 用于判断集合中是否存在满足条件的元素。  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> hasAdults = people.Any(p =&gt; p.Age &gt;= <span class="number">18</span>);</span><br></pre></td></tr></table></figure></li><li><p>All ： 用于判断集合中是否所有元素都满足条件。  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> allAdults = people.All(p =&gt; p.Age &gt;= <span class="number">18</span>);</span><br></pre></td></tr></table></figure></li><li><p>Count ： 用于计算集合中元素的数量。  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> count = people.Count();</span><br></pre></td></tr></table></figure></li><li><p>Sum &#x2F; Average &#x2F; Min &#x2F; Max ：用于计算集合中数值类型元素的总和、平均值、最小值和最大值。 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> totalAge = people.Sum(p =&gt; p.Age);</span><br><span class="line"><span class="keyword">var</span> averageAge = people.Average(p =&gt; p.Age);</span><br><span class="line"><span class="keyword">var</span> oldestPersonAge = people.Max(p =&gt; p.Age); </span><br><span class="line"><span class="keyword">var</span> youngestPersonAge = people.Min(p =&gt; p.Age);</span><br></pre></td></tr></table></figure></li><li><p>First &#x2F; FirstOrDefault &#x2F; Last &#x2F; LastOrDefault ：用于获取集合中的第一个或最后一个元素。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstPerson = people.First();</span><br><span class="line"><span class="keyword">var</span> firstAdult = people.FirstOrDefault(p =&gt; p.Age &gt;= <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> lastPerson = people.Last();</span><br></pre></td></tr></table></figure></li><li><p>SelectMany ： 用于将集合中的元素转换为另一个集合，然后将其展开。  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allOrders = people.SelectMany(p =&gt; p.Orders);</span><br></pre></td></tr></table></figure></li><li><p>ToList &#x2F; ToArray ： 用于将查询结果转换为列表或数组。  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> peopleList = people.ToList(); </span><br><span class="line"><span class="keyword">var</span> peopleArray = people.ToArray();</span><br></pre></td></tr></table></figure></li></ol><h3 id="Unity中使用ReactiveX"><a href="#Unity中使用ReactiveX" class="headerlink" title="Unity中使用ReactiveX"></a>Unity中使用ReactiveX</h3><h4 id="UnityEvent转换为Observable"><a href="#UnityEvent转换为Observable" class="headerlink" title="UnityEvent转换为Observable"></a>UnityEvent转换为Observable</h4><p>如果传递了 CancellationToken，则它允许事件源在调用 Cancel 时通过发出 OnCompleted 来调用事件取消订阅。例如，如果您传递了MonoBehaviour.destroyCancellationToken，它将与 GameObject 的生命周期一起可靠地取消订阅。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Unit&gt; <span class="title">AsObservable</span>(<span class="params"><span class="keyword">this</span> UnityEngine.Events.UnityEvent unityEvent, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; <span class="title">AsObservable</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> UnityEngine.Events.UnityEvent&lt;T&gt; unityEvent, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Observable</span>&lt;(<span class="title">T0</span> <span class="title">Arg0</span>, <span class="title">T1</span> <span class="title">Arg1</span>)&gt; <span class="title">AsObservable</span>&lt;<span class="title">T0</span>, <span class="title">T1</span>&gt;(<span class="params"><span class="keyword">this</span> UnityEngine.Events.UnityEvent&lt;T0, T1&gt; unityEvent, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Observable</span>&lt;(<span class="title">T0</span> <span class="title">Arg0</span>, <span class="title">T1</span> <span class="title">Arg1</span>, <span class="title">T2</span> <span class="title">Arg2</span>)&gt; <span class="title">AsObservable</span>&lt;<span class="title">T0</span>, <span class="title">T1</span>, <span class="title">T2</span>&gt;(<span class="params"><span class="keyword">this</span> UnityEngine.Events.UnityEvent&lt;T0, T1, T2&gt; unityEvent, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Observable</span>&lt;(<span class="title">T0</span> <span class="title">Arg0</span>, <span class="title">T1</span> <span class="title">Arg1</span>, <span class="title">T2</span> <span class="title">Arg2</span>, <span class="title">T3</span> <span class="title">Arg3</span>)&gt; <span class="title">AsObservable</span>&lt;<span class="title">T0</span>, <span class="title">T1</span>, <span class="title">T2</span>, <span class="title">T3</span>&gt;(<span class="params"><span class="keyword">this</span> UnityEngine.Events.UnityEvent&lt;T0, T1, T2, T3&gt; unityEvent, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br></pre></td></tr></table></figure><h4 id="UGUI拓展方法"><a href="#UGUI拓展方法" class="headerlink" title="UGUI拓展方法"></a>UGUI拓展方法</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDisposable <span class="title">SubscribeToText</span>(<span class="params"><span class="keyword">this</span> Observable&lt;<span class="built_in">string</span>&gt; source, Text text</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDisposable <span class="title">SubscribeToText</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> Observable&lt;T&gt; source, Text text</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDisposable <span class="title">SubscribeToText</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> Observable&lt;T&gt; source, Text text, Func&lt;T, <span class="built_in">string</span>&gt; selector</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDisposable <span class="title">SubscribeToInteractable</span>(<span class="params"><span class="keyword">this</span> Observable&lt;<span class="built_in">bool</span>&gt; source, Selectable selectable</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Unit&gt; <span class="title">OnClickAsObservable</span>(<span class="params"><span class="keyword">this</span> Button button</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;<span class="built_in">bool</span>&gt; <span class="title">OnValueChangedAsObservable</span>(<span class="params"><span class="keyword">this</span> Toggle toggle</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;<span class="built_in">float</span>&gt; <span class="title">OnValueChangedAsObservable</span>(<span class="params"><span class="keyword">this</span> Scrollbar scrollbar</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Vector2&gt; <span class="title">OnValueChangedAsObservable</span>(<span class="params"><span class="keyword">this</span> ScrollRect scrollRect</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;<span class="built_in">float</span>&gt; <span class="title">OnValueChangedAsObservable</span>(<span class="params"><span class="keyword">this</span> Slider slider</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;<span class="built_in">string</span>&gt; <span class="title">OnEndEditAsObservable</span>(<span class="params"><span class="keyword">this</span> InputField inputField</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;<span class="built_in">string</span>&gt; <span class="title">OnValueChangedAsObservable</span>(<span class="params"><span class="keyword">this</span> InputField inputField</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;<span class="built_in">int</span>&gt; <span class="title">OnValueChangedAsObservable</span>(<span class="params"><span class="keyword">this</span> Dropdown dropdown</span>)</span></span><br></pre></td></tr></table></figure><h4 id="可序列化响应式属性"><a href="#可序列化响应式属性" class="headerlink" title="可序列化响应式属性"></a>可序列化响应式属性</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewBehaviourScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;<span class="built_in">int</span>&gt; rpInt;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;<span class="built_in">long</span>&gt; rpLong;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;<span class="built_in">byte</span>&gt; rpByte;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;<span class="built_in">float</span>&gt; rpFloat;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;<span class="built_in">double</span>&gt; rpDouble;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;<span class="built_in">string</span>&gt; rpString;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;<span class="built_in">bool</span>&gt; rpBool;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;Vector2&gt; rpVector2;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;Vector2Int&gt; rpVector2Int;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;Vector3&gt; rpVector3;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;Vector3Int&gt; rpVector3Int;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;Vector4&gt; rpVector4;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;Color&gt; rpColor;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;Rect&gt; rpRect;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;Bounds&gt; rpBounds;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;BoundsInt&gt; rpBoundsInt;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;Quaternion&gt; rpQuaternion;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;Matrix4x4&gt; rpMatrix4x4;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;FruitEnum&gt; rpEnum;</span><br><span class="line">    <span class="keyword">public</span> SerializableReactiveProperty&lt;FruitFlagsEnum&gt; rpFlagsEnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> R3;</span><br><span class="line"><span class="keyword">using</span> R3.Triggers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// when using R3.Triggers, Component or GameObject has [MonoBehaviour Messages]AsObservable extension methods.</span></span><br><span class="line"><span class="keyword">this</span>.OnCollisionEnterAsObservable()</span><br><span class="line">    .Subscribe(x =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;collision enter&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="跟踪器（ObservableTracker-）"><a href="#跟踪器（ObservableTracker-）" class="headerlink" title="跟踪器（ObservableTracker ）"></a>跟踪器（ObservableTracker ）</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ObservableTracker.EnableTracking = <span class="literal">true</span>; <span class="comment">// default is false</span></span><br><span class="line">ObservableTracker.EnableStackTrace = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> d = Observable.Interval(TimeSpan.FromSeconds(<span class="number">1</span>))</span><br><span class="line">    .Where(x =&gt; <span class="literal">true</span>)</span><br><span class="line">    .Take(<span class="number">10000</span>)</span><br><span class="line">    .Subscribe();</span><br><span class="line"></span><br><span class="line"><span class="comment">// check subscription</span></span><br><span class="line">ObservableTracker.ForEachActiveTask(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(x);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反应式编程 </tag>
            
            <tag> 编程技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo图片加载问题</title>
      <link href="/2024/10/28/hexo%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
      <url>/2024/10/28/hexo%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="hexo无法加载本地图片的问题"><a href="#hexo无法加载本地图片的问题" class="headerlink" title="hexo无法加载本地图片的问题"></a>hexo无法加载本地图片的问题</h3><h4 id="1-下载hexo-asset-image插件"><a href="#1-下载hexo-asset-image插件" class="headerlink" title="1. 下载hexo-asset-image插件"></a>1. 下载hexo-asset-image插件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><h4 id="2-修改-config-yml文件，将hexo-asset-image设置为true"><a href="#2-修改-config-yml文件，将hexo-asset-image设置为true" class="headerlink" title="2. 修改_config.yml文件，将hexo-asset-image设置为true"></a>2. 修改_config.yml文件，将hexo-asset-image设置为true</h4><h4 id="3-新建文章-hexo-new-“我的文章”-然后在文章中插入图片，如："><a href="#3-新建文章-hexo-new-“我的文章”-然后在文章中插入图片，如：" class="headerlink" title="3. 新建文章 hexo new “我的文章”, 然后在文章中插入图片，如："></a>3. 新建文章 hexo new “我的文章”, 然后在文章中插入图片，如：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](我的文章/logo.png)</span><br></pre></td></tr></table></figure><h4 id="4-如果图片还不能显示，这是插件bug未修复"><a href="#4-如果图片还不能显示，这是插件bug未修复" class="headerlink" title="4. 如果图片还不能显示，这是插件bug未修复"></a>4. 如果图片还不能显示，这是插件bug未修复</h4><p>解决方案：</p><ol><li>找到node_modules\hexo-asset-image\index.js文件</li><li>找到if(&#x2F;.*/index.html$&#x2F;.test(link)) （大概在17行左右）</li><li>修改成如下代码 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(/.*\/index\.html$/.test(link)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">else if (link.charAt(link.length - 1) === &#x27;/&#x27;) &#123;</span><br><span class="line">    // link 是文件夹路径情形时</span><br><span class="line">    var endPos = link.length - 1;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>找到$(‘img’).each(function()) 代码，将其中 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(this).attr(&#x27;src&#x27;, config.root + link + src);</span><br><span class="line">console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span><br></pre></td></tr></table></figure> 改为相对路径引用 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(this).attr(&#x27;src&#x27;, link + src);</span><br><span class="line">console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+link + src);</span><br></pre></td></tr></table></figure></li><li>重新执行hexo clean、hexo g、hexo s</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PBR理论和渲染原理</title>
      <link href="/2024/10/27/PBR%E7%90%86%E8%AE%BA%E5%92%8C%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"/>
      <url>/2024/10/27/PBR%E7%90%86%E8%AE%BA%E5%92%8C%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="PBR是什么？"><a href="#PBR是什么？" class="headerlink" title="PBR是什么？"></a>PBR是什么？</h3><p>Physically Based Rendering，即基于物理的渲染。这是一种计算机图形学中的着色方法，它基于物理原理，而不是基于像素或顶点的颜色。PBR的主要思想是，物体的外观应该受到光照、材质、视角、距离、光线的影响，而不是受到像素或顶点的颜色影响。其目的在于，让渲染更加真实、更加自然。站在程序角度看，它可以使我们<strong>把材质与光照解耦</strong>。</p><p>PBR理论包括： 微平面模型、能量守恒、菲涅尔反射、线性空间和伽马矫正、色调映射、材质的光学特性、基于物理的光照模型、基于物理的渲染方程。</p><p>正因为PBR基于物理原理，这种方式与原来的Phong 或 Blinn-Phong等光照模型相比要更加真实一些。除了看起来更好些以外，由于它与物理性质非常接近，因此我们（尤其是美术师们）可以直接以物理参数为依据来编写表面材质，而不必依靠粗劣的修改与调整来让光照效果看上去正常。</p><h3 id="微平面模型"><a href="#微平面模型" class="headerlink" title="微平面模型"></a>微平面模型</h3><p>这项理论认为，达到微观尺度之后的任何平面都可以用被称为<strong>微平面</strong>（microfacet）的小型表面片来近似。微平面是由微观尺度的粗糙度、法线分布和粗糙度分布所决定的。</p><p>根据平面粗糙程度的不同，这些细小镜面的取向排列可以相当不一致。产生的效果就是：一个平面越是粗糙，这个平面上的微平面的排列就越混乱。 这些微小镜面这样无序取向排列的影响就是，当我们特指镜面光&#x2F;镜面反射时，入射光线更趋向于向完全不同的方向 发散 (Scatter)开来，进而产生出分布范围更广泛的镜面反射。 而与之相反的是，对于一个光滑的平面，光线大体上会更趋向于向同一个方向反射，造成更小更锐利的反射：<br><img src="image.png" alt="渲染流水线"></p><p>微平面模型可以模拟出各种各样的材质，包括金属、玻璃、水泥、皮革、木材、水、沙子、石头、水晶、玻璃、水泥、皮革、木材等。</p><h3 id="能量守恒"><a href="#能量守恒" class="headerlink" title="能量守恒"></a>能量守恒</h3><pre><code>出射光线的能量永远不能超过入射光线的能量</code></pre><p>为了遵守能量守恒定律，我们需要对漫反射光和镜面反射光做出明确的区分。 当一束光线碰撞到一个表面的时候，它就会分离成一个折射部分和一个反射部分。 反射部分就是会直接反射开而不进入平面的那部分光线，也就是我们所说的镜面光照。 而折射部分就是余下的会进入表面并被吸收的那部分光线，也就是我们所说的漫反射光照。</p><h3 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h3><p><img src="image2.png" alt="渲染流水线"><br>L : 辐射率<br>P : 物体表面上的一个点<br>v : 视线方向<br>l : 入射光线方向<br>n : p点的法线<br>f : BRDF<br><img src="image3.png" alt="渲染流水线"><br>在半球域内，对所有入射光线进行积分<br><strong>BRDF</strong>(Bidirectional Reflective Distribution Function) :  <strong>双向反射分布函数</strong>, 反映了物体表面上不同方向的反射率分布。  </p><h3 id="菲涅尔方程"><a href="#菲涅尔方程" class="headerlink" title="菲涅尔方程"></a>菲涅尔方程</h3><p>菲涅尔方程描述的是<strong>光在两种不同折射率的介质中传播时的反射和折射</strong><br><img src="fresnel.png" alt="渲染流水线">  </p><h3 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h3><p>线性空间是指光线的三维空间，它与物体的三维空间不同。在线性空间中，光线的方向是由光源的位置和方向决定的，而物体的位置和形状则是由模型的位置和形状决定的。</p><h3 id="伽马矫正"><a href="#伽马矫正" class="headerlink" title="伽马矫正"></a>伽马矫正</h3><p>伽马矫正是一种颜色空间转换，它将线性空间中的颜色值转换为非线性空间中的颜色值。在计算机屏幕上，我们通常使用非线性空间来表示颜色，以方便人眼观察。然而，在计算机程序中，我们通常使用线性空间来计算颜色，以方便计算机计算。所以为了使计算机计算的结果真实的显示在显示屏上，我们需要对颜色进行伽马矫正。  </p><pre><code>监视器所显示出来的图像和线性图像的最小亮度是相同的，它们最大的亮度也是相同的；只是中间亮度部分会被压暗。</code></pre><h3 id="PBR材质"><a href="#PBR材质" class="headerlink" title="PBR材质"></a>PBR材质</h3><p>通常，美术师们会根据物体的材质属性来制作PBR贴图。材质的贴图通常包括：</p><ul><li>反射率(Albedo)：反照率 (Albedo)纹理为每一个金属的纹素(Texel)（纹理像素）指定表面颜色或者基础反射率。和漫反射纹理类似。</li><li>粗糙度(Roughness)：粗糙度(Roughness)贴图可以以纹素为单位指定某个表面有多粗糙。</li><li>金属度(Metallic)：金属(Metallic)贴图逐个纹素的指定该纹素是不是金属质地的。 根据PBR引擎设置的不同，美术师们既可以将金属度编写为灰度值又可以编写为1或0这样的二元值。</li><li>环境光遮蔽 (Ambient Occlusion)：即AO贴图。AO 贴图为表面和周围潜在的几何图形指定了一个额外的阴影因子。</li><li>法线(Normal)：法线贴图表示物体表面上每个点的法线方向，利用法线贴图可以制造出起伏不平的假象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 渲染 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PBR </tag>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渲染流水线</title>
      <link href="/2024/10/20/UnityShader%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/10/20/UnityShader%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h3><p>参考书籍《Unity Shader入门精要》</p><ul><li>渲染流水线是指将场景中的物体从摄像机视角投射到屏幕上，经过各种处理后最终呈现在屏幕上的过程。</li><li>当前，游戏引擎的渲染流水线一般分为三个阶段：<strong>应用阶段、几何阶段、光栅化阶段</strong>。另外，游戏引擎还会有一些其他阶段，如<strong>屏幕后处理阶段</strong>。</li></ul><p><img src="image1.png" alt="渲染流水线"></p><h4 id="应用阶段"><a href="#应用阶段" class="headerlink" title="应用阶段"></a>应用阶段</h4><ul><li>准备基本场景数据：<ul><li>物体Transform数据：位置、旋转、缩放。</li><li>物体网格数据：顶点、法线、切线、UV坐标等。</li><li>光照数据：光源类型（平行光、点光源、聚光灯、环境光）、光源位置、方向、颜色、阴影（光源可见范围内是否有投射阴影的物体）、阴影参数等（光源序号、阴影强度、级联参数、深度偏移、近平面偏移等）。</li><li>摄相机数据：位置和方向、远近裁剪平面、正交、透视（FOV）、视口比例和尺寸等。</li></ul></li><li>加速算法、粗粒度剔除： 使用算法加速场景物体的裁剪，并将不可见的物体剔除出去。</li><li>设置渲染状态、准备渲染参数：设置渲染状态，如深度测试、混合、模板测试、剔除、深度写入等。准备渲染参数，如光照、阴影、雾效、反射等。设置渲染模式：前向渲染、延迟渲染、光照预计算、混合渲染、自定义渲染路径。这一阶段最重要的输出是渲染所需的几何信息，即<strong>渲染图元</strong>。</li><li>调用DrawCall：将顶点数据如位置、颜色、法线、纹理uv坐标等传递给GPU，并调用DrawCall函数进行渲染。</li></ul><h4 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h4><pre><code>几何阶段负责处理每个渲染图元，进行逐顶点、逐多边形的操作。这一阶段主要任务是将顶点坐标变换到屏幕空间下。</code></pre><p><img src="image2.png" alt="几何阶段"></p><ul><li>顶点着色器：对每个顶点进行处理，如位置、颜色、法线、纹理坐标等。可以利用这一阶段对顶点位置进行变换实现顶点动画，如布料、水面、旗帜等。但是无论怎么变换，顶点着色器都必须把顶点坐标变换到齐次裁剪空间下，然后由硬件设备进行透视除法，得到归一化的设备坐标。</li><li>裁剪：将物体的几何形状处于摄像机视角之外的部分裁剪掉，以节省渲染时间和资源。这一步不可编程，由硬件控制，但可以配置。</li></ul><p><img src="image3.png" alt="裁剪阶段"></p><ul><li>屏幕映射：将物体的几何形状从齐次裁剪空间映射到屏幕空间。</li></ul><h4 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h4><pre><code>光栅化阶段负责将渲染图元转化为屏幕上的点、线、面。这一阶段的输出是渲染像素，即“片元”。</code></pre><ul><li>三角形设置：几何阶段输出的信息是屏幕坐标下顶点的位置和额外信息（深度值、法线、视角方向等）。三角形设置阶段根据这些信息设置三角网格的边界表示方式。</li><li>三角形遍历：这个阶段会检查每个像素是否被一个三角形所覆盖，如果被覆盖，就会生成一个<strong>片元</strong>。这个过程就叫做三角形遍历，也称<strong>扫描变换</strong>。</li><li>片元着色器：这是一个非常重要的可编程着色器阶段。在DirectX中，它被称为<strong>像素着色器</strong>，在OpenGL中，它被称为<strong>片元着色器</strong>。<ul><li>前面光栅化阶段并不会影响屏幕上每个像素的颜色值，而是生成一个<strong>片元</strong>，每个片元负责存储一个三角形网格是怎样覆盖每个像素的。</li><li>片元着色器的输入是上一阶段对顶点信息插值得到的结果，它的输出是一个或者多个具体的颜色值。这一阶段是真正上色、贴图的阶段，</li><li>这一阶段有个比较重要的技术：<strong>纹理采样</strong>。通常我们会在顶点着色器中输出每个顶点的纹理坐标，然后经过光栅化阶段对三角形网格的3个顶点对应的纹理坐标进行插值后，得到其覆盖的片元的纹理坐标。</li></ul></li><li>逐片元操作：DirectX中称<strong>输出合并阶段</strong><ul><li>这一阶段有很多测试操作，如模板测试、深度测试、混合、剔除等。</li><li>模板测试：GPU读取模板缓冲区中该片元位置的模板值，然后将该值和读取到参考值进行比较，比较函数可由开发者决定。如果比较不通过，及没有通过模板测试，则会丢弃该片元。</li><li>深度测试：高度可配置。如果开启深度测试，GPU会把该片元的深度值和已经存在于深度缓冲中的深度值进行比较，比较函数可由开发者决定，通常是小于等于。如果比较不通过，即被遮挡，则丢弃该片元。开发者还可以开启&#x2F;关闭深度写入，比较通过后，则会把该片元的深度值写入深度缓冲区。透明效果和深度测试以及深度写入密切相关。</li></ul></li></ul><h4 id="屏幕后处理阶段"><a href="#屏幕后处理阶段" class="headerlink" title="屏幕后处理阶段"></a>屏幕后处理阶段</h4><pre><code>    屏幕后处理是实现游戏中屏幕特效的常见方法。通常指的是在渲染完整个场景得到屏幕图像后，再对这个图像进行一系列的操作，实现各种屏幕特效。可以为游戏画面添加更多的艺术效果，例如景深、运动模糊等。</code></pre>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> UnityShader </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
