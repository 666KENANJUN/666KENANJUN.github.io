<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PBR理论和渲染原理</title>
      <link href="/2024/10/27/PBR%E7%90%86%E8%AE%BA%E5%92%8C%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"/>
      <url>/2024/10/27/PBR%E7%90%86%E8%AE%BA%E5%92%8C%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="PBR是什么？"><a href="#PBR是什么？" class="headerlink" title="PBR是什么？"></a>PBR是什么？</h3><p>Physically Based Rendering，即基于物理的渲染。这是一种计算机图形学中的着色方法，它基于物理原理，而不是基于像素或顶点的颜色。PBR的主要思想是，物体的外观应该受到光照、材质、视角、距离、光线的影响，而不是受到像素或顶点的颜色影响。其目的在于，让渲染更加真实、更加自然。站在程序角度看，它可以使我们<strong>把材质与光照解耦</strong>。</p><p>PBR理论包括： 微平面模型、能量守恒、菲涅尔反射、线性空间和伽马矫正、色调映射、材质的光学特性、基于物理的光照模型、基于物理的渲染方程。</p><p>正因为PBR基于物理原理，这种方式与原来的Phong 或 Blinn-Phong等光照模型相比要更加真实一些。除了看起来更好些以外，由于它与物理性质非常接近，因此我们（尤其是美术师们）可以直接以物理参数为依据来编写表面材质，而不必依靠粗劣的修改与调整来让光照效果看上去正常。</p><h3 id="微平面模型"><a href="#微平面模型" class="headerlink" title="微平面模型"></a>微平面模型</h3><p>这项理论认为，达到微观尺度之后的任何平面都可以用被称为<strong>微平面</strong>（microfacet）的小型表面片来近似。微平面是由微观尺度的粗糙度、法线分布和粗糙度分布所决定的。</p><p>根据平面粗糙程度的不同，这些细小镜面的取向排列可以相当不一致。产生的效果就是：一个平面越是粗糙，这个平面上的微平面的排列就越混乱。 这些微小镜面这样无序取向排列的影响就是，当我们特指镜面光&#x2F;镜面反射时，入射光线更趋向于向完全不同的方向 发散 (Scatter)开来，进而产生出分布范围更广泛的镜面反射。 而与之相反的是，对于一个光滑的平面，光线大体上会更趋向于向同一个方向反射，造成更小更锐利的反射：<br><img src="image.png" alt="渲染流水线"></p><p>微平面模型可以模拟出各种各样的材质，包括金属、玻璃、水泥、皮革、木材、水、沙子、石头、水晶、玻璃、水泥、皮革、木材等。</p><h3 id="能量守恒"><a href="#能量守恒" class="headerlink" title="能量守恒"></a>能量守恒</h3><pre><code>出射光线的能量永远不能超过入射光线的能量</code></pre><p>为了遵守能量守恒定律，我们需要对漫反射光和镜面反射光做出明确的区分。 当一束光线碰撞到一个表面的时候，它就会分离成一个折射部分和一个反射部分。 反射部分就是会直接反射开而不进入平面的那部分光线，也就是我们所说的镜面光照。 而折射部分就是余下的会进入表面并被吸收的那部分光线，也就是我们所说的漫反射光照。</p><h3 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h3><p><img src="image2.png" alt="渲染流水线"><br>L : 辐射率<br>P : 物体表面上的一个点<br>v : 视线方向<br>l : 入射光线方向<br>n : p点的法线<br>f : BRDF<br>$$<br>\begin{aligned}<br>   \int\limits_H … \mathrm{d} l<br>\end{aligned}<br>$$<br>在半球域内，对所有入射光线进行积分<br><strong>BRDF</strong>(Bidirectional Reflective Distribution Function) :  <strong>双向反射分布函数</strong>, 反映了物体表面上不同方向的反射率分布。  </p><h3 id="菲涅尔方程"><a href="#菲涅尔方程" class="headerlink" title="菲涅尔方程"></a>菲涅尔方程</h3><p>菲涅尔方程描述的是<strong>光在两种不同折射率的介质中传播时的反射和折射</strong><br><img src="fresnel.png" alt="渲染流水线">  </p><h3 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h3><p>线性空间是指光线的三维空间，它与物体的三维空间不同。在线性空间中，光线的方向是由光源的位置和方向决定的，而物体的位置和形状则是由模型的位置和形状决定的。</p><h3 id="伽马矫正"><a href="#伽马矫正" class="headerlink" title="伽马矫正"></a>伽马矫正</h3><p>伽马矫正是一种颜色空间转换，它将线性空间中的颜色值转换为非线性空间中的颜色值。在计算机屏幕上，我们通常使用非线性空间来表示颜色，以方便人眼观察。然而，在计算机程序中，我们通常使用线性空间来计算颜色，以方便计算机计算。所以为了使计算机计算的结果真实的显示在显示屏上，我们需要对颜色进行伽马矫正。  </p><pre><code>监视器所显示出来的图像和线性图像的最小亮度是相同的，它们最大的亮度也是相同的；只是中间亮度部分会被压暗。</code></pre><h3 id="PBR材质"><a href="#PBR材质" class="headerlink" title="PBR材质"></a>PBR材质</h3><p>通常，美术师们会根据物体的材质属性来制作PBR贴图。材质的贴图通常包括：</p><ul><li>反射率(Albedo)：反照率 (Albedo)纹理为每一个金属的纹素(Texel)（纹理像素）指定表面颜色或者基础反射率。和漫反射纹理类似。</li><li>粗糙度(Roughness)：粗糙度(Roughness)贴图可以以纹素为单位指定某个表面有多粗糙。</li><li>金属度(Metallic)：金属(Metallic)贴图逐个纹素的指定该纹素是不是金属质地的。 根据PBR引擎设置的不同，美术师们既可以将金属度编写为灰度值又可以编写为1或0这样的二元值。</li><li>环境光遮蔽 (Ambient Occlusion)：即AO贴图。AO 贴图为表面和周围潜在的几何图形指定了一个额外的阴影因子。</li><li>法线(Normal)：法线贴图表示物体表面上每个点的法线方向，利用法线贴图可以制造出起伏不平的假象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 渲染 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PBR </tag>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渲染流水线</title>
      <link href="/2024/10/20/UnityShader%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/10/20/UnityShader%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h3><p>参考书籍《Unity Shader入门精要》</p><ul><li>渲染流水线是指将场景中的物体从摄像机视角投射到屏幕上，经过各种处理后最终呈现在屏幕上的过程。</li><li>当前，游戏引擎的渲染流水线一般分为三个阶段：<strong>应用阶段、几何阶段、光栅化阶段</strong>。另外，游戏引擎还会有一些其他阶段，如<strong>屏幕后处理阶段</strong>。</li></ul><p><img src="image1.png" alt="渲染流水线"></p><h4 id="应用阶段"><a href="#应用阶段" class="headerlink" title="应用阶段"></a>应用阶段</h4><ul><li>准备基本场景数据：<ul><li>物体Transform数据：位置、旋转、缩放。</li><li>物体网格数据：顶点、法线、切线、UV坐标等。</li><li>光照数据：光源类型（平行光、点光源、聚光灯、环境光）、光源位置、方向、颜色、阴影（光源可见范围内是否有投射阴影的物体）、阴影参数等（光源序号、阴影强度、级联参数、深度偏移、近平面偏移等）。</li><li>摄相机数据：位置和方向、远近裁剪平面、正交、透视（FOV）、视口比例和尺寸等。</li></ul></li><li>加速算法、粗粒度剔除： 使用算法加速场景物体的裁剪，并将不可见的物体剔除出去。</li><li>设置渲染状态、准备渲染参数：设置渲染状态，如深度测试、混合、模板测试、剔除、深度写入等。准备渲染参数，如光照、阴影、雾效、反射等。设置渲染模式：前向渲染、延迟渲染、光照预计算、混合渲染、自定义渲染路径。这一阶段最重要的输出是渲染所需的几何信息，即<strong>渲染图元</strong>。</li><li>调用DrawCall：将顶点数据如位置、颜色、法线、纹理uv坐标等传递给GPU，并调用DrawCall函数进行渲染。</li></ul><h4 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h4><pre><code>几何阶段负责处理每个渲染图元，进行逐顶点、逐多边形的操作。这一阶段主要任务是将顶点坐标变换到屏幕空间下。</code></pre><p><img src="image2.png" alt="几何阶段"></p><ul><li>顶点着色器：对每个顶点进行处理，如位置、颜色、法线、纹理坐标等。可以利用这一阶段对顶点位置进行变换实现顶点动画，如布料、水面、旗帜等。但是无论怎么变换，顶点着色器都必须把顶点坐标变换到齐次裁剪空间下，然后由硬件设备进行透视除法，得到归一化的设备坐标。</li><li>裁剪：将物体的几何形状处于摄像机视角之外的部分裁剪掉，以节省渲染时间和资源。这一步不可编程，由硬件控制，但可以配置。</li></ul><p><img src="image3.png" alt="裁剪阶段"></p><ul><li>屏幕映射：将物体的几何形状从齐次裁剪空间映射到屏幕空间。</li></ul><h4 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h4><pre><code>光栅化阶段负责将渲染图元转化为屏幕上的点、线、面。这一阶段的输出是渲染像素，即“片元”。</code></pre><ul><li>三角形设置：几何阶段输出的信息是屏幕坐标下顶点的位置和额外信息（深度值、法线、视角方向等）。三角形设置阶段根据这些信息设置三角网格的边界表示方式。</li><li>三角形遍历：这个阶段会检查每个像素是否被一个三角形所覆盖，如果被覆盖，就会生成一个<strong>片元</strong>。这个过程就叫做三角形遍历，也称<strong>扫描变换</strong>。</li><li>片元着色器：这是一个非常重要的可编程着色器阶段。在DirectX中，它被称为<strong>像素着色器</strong>，在OpenGL中，它被称为<strong>片元着色器</strong>。<ul><li>前面光栅化阶段并不会影响屏幕上每个像素的颜色值，而是生成一个<strong>片元</strong>，每个片元负责存储一个三角形网格是怎样覆盖每个像素的。</li><li>片元着色器的输入是上一阶段对顶点信息插值得到的结果，它的输出是一个或者多个具体的颜色值。这一阶段是真正上色、贴图的阶段，</li><li>这一阶段有个比较重要的技术：<strong>纹理采样</strong>。通常我们会在顶点着色器中输出每个顶点的纹理坐标，然后经过光栅化阶段对三角形网格的3个顶点对应的纹理坐标进行插值后，得到其覆盖的片元的纹理坐标。</li></ul></li><li>逐片元操作：DirectX中称<strong>输出合并阶段</strong><ul><li>这一阶段有很多测试操作，如模板测试、深度测试、混合、剔除等。</li><li>模板测试：GPU读取模板缓冲区中该片元位置的模板值，然后将该值和读取到参考值进行比较，比较函数可由开发者决定。如果比较不通过，及没有通过模板测试，则会丢弃该片元。</li><li>深度测试：高度可配置。如果开启深度测试，GPU会把该片元的深度值和已经存在于深度缓冲中的深度值进行比较，比较函数可由开发者决定，通常是小于等于。如果比较不通过，即被遮挡，则丢弃该片元。开发者还可以开启&#x2F;关闭深度写入，比较通过后，则会把该片元的深度值写入深度缓冲区。透明效果和深度测试以及深度写入密切相关。</li></ul></li></ul><h4 id="屏幕后处理阶段"><a href="#屏幕后处理阶段" class="headerlink" title="屏幕后处理阶段"></a>屏幕后处理阶段</h4><pre><code>    屏幕后处理是实现游戏中屏幕特效的常见方法。通常指的是在渲染完整个场景得到屏幕图像后，再对这个图像进行一系列的操作，实现各种屏幕特效。可以为游戏画面添加更多的艺术效果，例如景深、运动模糊等。</code></pre>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> UnityShader </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
